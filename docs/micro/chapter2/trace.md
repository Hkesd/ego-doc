## 6 Ego Access 自定义链路

日志、链路、监控可以说是微服务治理的三驾马车，如下所示。
![img_1.png](../../images/egoaccesstrace1.png)

从图中，我们可以看到日志、链路、监控其实是有很多不一样的地方，同时又有一些交汇的地方。 本篇文章中，主要探讨下日志和链路的区别和统一。

| 方式    | 采集类型  | 量级    |  优势    | 调整采集   |格式   |
|  ----  | ----  | ---- |---- |---- | ----  |
| 日志    | 请求、错误、慢日志 | 中 | 聚合、错误收敛 | 调整日志级别 | 动态   |
| 链路    | 请求日志（可以细粒度到函数级别） | 大 | traceId，调用关系  | 调整采样率| 固定   |

上面的表格，展示了日志和链路的一些特点，可以看到日志和链路都有记录请求日志。

链路记录的请求日志指标较多，同时可以细粒度到函数级别，最重要的是有全局唯一的trace id，能够串联各个系统的耗时、错误情况，但是他存在的最大问题是因为粒度较细，数据量巨大，只能采样，导致了有些数据可能缺失，同时他也不能聚合一些错误信息，做一些错误收敛。

而传统的框架请求日志，可以记录错误信息、错误收敛，但却没有链路的一些优秀特性。

这两者是否能做个结合和统一呢，一方面能够将链路数据串联起来，另一方面能将数据做一些聚合。

在这里我们将Ego框架里的access日志改造成具有链路的特性，能够记录trace id串联各个服务，并且能够根据用户自定义的字段，记录uid、orderId等信息。

这个是如何实现的呢，我们以一个获取用户信息的例子来讲述下他的数据流向。

假设我们有两个服务，一个是HTTP a服务用于将用户信息数据吐给客户端，一个是gRPC b服务用于查询MySQL，将用户信息数据返给a服务。

* 我们在a、b服务启动前配置自定义的链路属性`export EGO_LOG_EXTRA_KEYS=X-Ego-Uid`，那么框架在读到这个环境变量里`EGO_LOG_EXTRA_KEYS`，会根据逗号分割，解析用户配置了多少个自定义的链路属性，后续的`Ego`组件会根据这个属性，自动将组件日志里追加这些用户自定义属性。
* 当a服务接收到客户端的请求后，会根据token校验，校验通过后，在`http.Request.Context()`中写入`X-Ego-Uid=9527`的数据
* 然后a服务，会将`http.Request.Context()`传入到`gRPC`客户端
* `gRPC`客户端会取出`gRPC context`中的`X-Ego-Uid=9527`，并将其写入到`gRPC header`里，调用b服务
* b服务接收到`gRPC header`中的`X-Ego-Uid=9527`，将其写入到`Context`里，传入到`MySQL`客户端
* `MySQL`客户端从`Context`里获取到`X-Ego-Uid=9527`
* 最后各个组件一次响应，并异步写入日志，在日志中追加`trace-id`和`x-ego-uid`（链路id，框架已经内置，会自动追加，不需要用户配置）。

![img.png](../../images/egoaccesstrace2.png)

以上就是Ego将日志中实现了链路的数据流向。快来体验吧。

更新版本为：
* github.com/gotomicro/ego@v0.6.2
* github.com/gotomicro/ego-component/egorm@v0.2.2
* github.com/gotomicro/ego-component/eredis@v0.2.3